// Data loader utility for static API data
// This module loads data from JSON files generated by the fetch-data script

import recipesData from "./recipes.json";
import categoriesData from "./categories.json";
import websitesData from "./websites.json";
import menuItemsData from "./menu-items.json";
import apiData from "./api-data.json";

import type { Recipe, Category, Website, MenuItem, ApiData } from "./api-types";
import { recipeNameToSlug, recipeSlugToSearchTerm } from "../utils/slugify";

/**
 * Check if we have fetched data available
 */
export function hasApiData(): boolean {
  try {
    return Array.isArray(recipesData) && recipesData.length > 0;
  } catch {
    return false;
  }
}

/**
 * Get all recipes
 */
export function getRecipes(): Recipe[] {
  return recipesData as Recipe[];
}

/**
 * Get recipe by ID
 */
export function getRecipeById(id: number): Recipe | undefined {
  const recipes = getRecipes();
  return recipes.find((recipe) => recipe.id === id);
}

/**
 * Get recipe by URL slug from the API's recipeURL field
 */
export function getRecipeBySlug(slug: string): Recipe | undefined {
  const recipes = getRecipes();

  // First try exact match with API's recipeURL (remove leading /recipe/ if present)
  const targetPath = slug.startsWith("recipe/")
    ? `/${slug}`
    : `/recipe/${slug}`;
  let recipe = recipes.find((recipe) => recipe.recipeURL === targetPath);

  // If no exact match with recipeURL, try generated slug from name
  if (!recipe) {
    const searchTerm = recipeSlugToSearchTerm(slug);
    recipe = recipes.find((recipe) => recipeNameToSlug(recipe.name) === slug);
  }

  // If still no exact match, try fuzzy search
  if (!recipe) {
    const searchTerm = recipeSlugToSearchTerm(slug);
    recipe = recipes.find((recipe) =>
      recipe.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }

  return recipe;
}

/**
 * Generate SEO-friendly slug for a recipe using API's recipeURL if available
 */
export function getRecipeSlug(recipe: Recipe): string {
  // Use the API's recipeURL if available, otherwise fall back to generated slug
  if (recipe.recipeURL) {
    // Extract the slug part from /recipe/slug-name
    const match = recipe.recipeURL.match(/\/recipe\/(.+)$/);
    if (match) {
      return match[1];
    }
  }
  // Fallback to generated slug from name
  return recipeNameToSlug(recipe.name);
}

/**
 * Get recipe URL path using API's recipeURL if available
 */
export function getRecipeUrl(recipe: Recipe): string {
  // Use the API's recipeURL if available, otherwise construct from slug
  if (recipe.recipeURL && recipe.recipeURL.startsWith("/recipe/")) {
    return recipe.recipeURL;
  }
  // Fallback to constructed URL
  return `/recipe/${getRecipeSlug(recipe)}`;
}

/**
 * Get recipes by category ID
 */
export function getRecipesByCategory(categoryId: number): Recipe[] {
  const recipes = getRecipes();
  return recipes.filter((recipe) => recipe.recipeCategoryID === categoryId);
}

/**
 * Get all categories
 */
export function getCategories(): Category[] {
  return categoriesData as Category[];
}

/**
 * Get category by ID
 */
export function getCategoryById(id: number): Category | undefined {
  const categories = getCategories();
  return categories.find((category) => category.id === id);
}

/**
 * Get category by URL slug
 */
export function getCategoryBySlug(slug: string): Category | undefined {
  const categories = getCategories();
  return categories.find((category) => category.url === slug);
}

/**
 * Get all websites
 */
export function getWebsites(): Website[] {
  return websitesData as Website[];
}

/**
 * Get website by ID
 */
export function getWebsiteById(id: number): Website | undefined {
  const websites = getWebsites();
  return websites.find((website) => website.id === id);
}

/**
 * Get menu items for a website
 */
export function getMenuItemsByWebsite(websiteId: number): MenuItem[] {
  const menuItems = menuItemsData as Record<number, MenuItem[]>;
  return menuItems[websiteId] || [];
}

/**
 * Get complete API data with metadata
 */
export function getApiData(): ApiData {
  return apiData as ApiData;
}

/**
 * Search recipes by name, description, or ingredients
 */
export function searchRecipes(query: string): Recipe[] {
  if (!query.trim()) return [];

  const recipes = getRecipes();
  const searchTerm = query.toLowerCase();

  return recipes.filter(
    (recipe) =>
      recipe.name?.toLowerCase().includes(searchTerm) ||
      recipe.description?.toLowerCase().includes(searchTerm) ||
      recipe.ingredients?.toLowerCase().includes(searchTerm)
  );
}

/**
 * Get featured recipes (highest rated or most recent)
 */
export function getFeaturedRecipes(limit: number = 6): Recipe[] {
  const recipes = getRecipes();

  // Sort by average rating (descending) and then by creation date (most recent)
  return recipes
    .sort((a, b) => {
      const ratingA = a.averageRating || 0;
      const ratingB = b.averageRating || 0;

      if (ratingA !== ratingB) {
        return ratingB - ratingA;
      }

      // Secondary sort by creation date
      const dateA = new Date(a.createdDT || 0);
      const dateB = new Date(b.createdDT || 0);
      return dateB.getTime() - dateA.getTime();
    })
    .slice(0, limit);
}

/**
 * Get recipe statistics
 */
export function getRecipeStats() {
  const recipes = getRecipes();
  const categories = getCategories();

  const stats = {
    totalRecipes: recipes.length,
    totalCategories: categories.length,
    averageRating: 0,
    recipesByCategory: {} as Record<string, number>,
    recentRecipes: 0,
  };

  // Calculate average rating
  const ratedRecipes = recipes.filter((r) => r.averageRating);
  if (ratedRecipes.length > 0) {
    stats.averageRating =
      ratedRecipes.reduce((sum, r) => sum + (r.averageRating || 0), 0) /
      ratedRecipes.length;
  }

  // Count recipes by category
  categories.forEach((category) => {
    const count = recipes.filter(
      (r) => r.recipeCategoryID === category.id
    ).length;
    stats.recipesByCategory[category.name] = count;
  });

  // Count recent recipes (last 30 days)
  const thirtyDaysAgo = new Date();
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
  stats.recentRecipes = recipes.filter((r) => {
    const createdDate = new Date(r.createdDT || 0);
    return createdDate > thirtyDaysAgo;
  }).length;

  return stats;
}

/**
 * Get data freshness information
 */
export function getDataMetadata() {
  try {
    const data = getApiData();
    return data.metadata;
  } catch {
    return {
      fetchedAt: "Unknown",
      totalRecipes: 0,
      totalCategories: 0,
      totalWebsites: 0,
    };
  }
}
