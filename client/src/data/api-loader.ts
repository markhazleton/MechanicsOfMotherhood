// Data loader utility for static API data
// This module loads data from JSON files generated by the fetch-data script

import recipesData from "./recipes.json";
import categoriesData from "./categories.json";
import websitesData from "./websites.json";
import menuItemsData from "./menu-items.json";
import apiData from "./api-data.json";

import type { Recipe, Category, Website, MenuItem, ApiData } from "./api-types";
import { recipeNameToSlug, recipeSlugToSearchTerm } from "../utils/slugify";

/**
 * Normalize slug for comparison (handle edge cases with special characters)
 */
function normalizeSlugForComparison(slug: string): string {
  return slug
    .toLowerCase()
    .replace(/--+/g, "-") // Multiple hyphens â†’ single hyphen
    .replace(/[()]/g, "") // Remove parentheses
    .replace(/:/g, "") // Remove colons
    .replace(/^-|-$/g, ""); // Trim leading/trailing hyphens
}

/**
 * Check if we have fetched data available
 */
export function hasApiData(): boolean {
  try {
    return Array.isArray(recipesData) && recipesData.length > 0;
  } catch {
    return false;
  }
}

/**
 * Get all recipes
 */
export function getRecipes(): Recipe[] {
  return recipesData as Recipe[];
}

/**
 * Get recipe by ID
 */
export function getRecipeById(id: number): Recipe | undefined {
  const recipes = getRecipes();
  return recipes.find((recipe) => recipe.id === id);
}

/**
 * Get recipe by URL slug from the API's recipeURL field
 */
export function getRecipeBySlug(slug: string): Recipe | undefined {
  const recipes = getRecipes();
  const normalizedInputSlug = normalizeSlugForComparison(slug);

  // First try exact match with API's recipeURL (remove leading /recipe/ if present)
  const targetPath = slug.startsWith("recipe/")
    ? `/${slug}`
    : `/recipe/${slug}`;
  let recipe = recipes.find((recipe) => recipe.recipeURL === targetPath);

  // If no exact match with recipeURL, try generated slug from name
  if (!recipe) {
    recipe = recipes.find((recipe) => {
      const recipeSlug = recipeNameToSlug(recipe.name);
      return normalizeSlugForComparison(recipeSlug) === normalizedInputSlug;
    });
  }

  // If no match with normalized comparison, try API recipeURL normalization
  if (!recipe) {
    recipe = recipes.find((recipe) => {
      if (recipe.recipeURL) {
        const match = recipe.recipeURL.match(/\/recipe\/(.+)$/);
        if (match && match[1]) {
          return normalizeSlugForComparison(match[1]) === normalizedInputSlug;
        }
      }
      return false;
    });
  }

  // If still no exact match, try fuzzy search
  if (!recipe) {
    const searchTerm = recipeSlugToSearchTerm(slug);
    recipe = recipes.find((recipe) =>
      recipe.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }

  return recipe;
}

/**
 * Generate SEO-friendly slug for a recipe using API's recipeURL if available
 */
export function getRecipeSlug(recipe: Recipe): string {
  // Use the API's recipeURL if available, otherwise fall back to generated slug
  if (recipe.recipeURL) {
    // Extract the slug part from /recipe/slug-name
    const match = recipe.recipeURL.match(/\/recipe\/(.+)$/);
    if (match && match[1]) {
      return match[1];
    }
  }
  // Fallback to generated slug from name
  return recipeNameToSlug(recipe.name);
}

/**
 * Get recipe URL path using API's recipeURL if available
 */
export function getRecipeUrl(recipe: Recipe): string {
  // Use the API's recipeURL if available, otherwise construct from slug
  if (recipe.recipeURL && recipe.recipeURL.startsWith("/recipe/")) {
    return recipe.recipeURL;
  }
  // Fallback to constructed URL
  return `/recipe/${getRecipeSlug(recipe)}`;
}

/**
 * Get recipes by category ID
 */
export function getRecipesByCategory(categoryId: number): Recipe[] {
  const recipes = getRecipes();
  return recipes.filter((recipe) => recipe.recipeCategoryID === categoryId);
}

/**
 * Get all categories
 */
export function getCategories(): Category[] {
  return categoriesData as Category[];
}

/**
 * Get category by ID
 */
export function getCategoryById(id: number): Category | undefined {
  const categories = getCategories();
  return categories.find((category) => category.id === id);
}

/**
 * Get category by URL slug
 */
export function getCategoryBySlug(slug: string): Category | undefined {
  const categories = getCategories();
  return categories.find((category) => category.url === slug);
}

/**
 * Get all websites
 */
export function getWebsites(): Website[] {
  // Safe type conversion with fallback structure
  return (websitesData as any[]).map(
    (site: any) =>
      ({
        id: site.id || 0,
        name: site.name || "",
        description: site.description || "",
        siteTemplate: site.siteTemplate || "",
        siteStyle: site.siteStyle || "",
        message: site.message || "",
        siteName: site.siteName || "",
        websiteUrl: site.websiteUrl || "",
        websiteTitle: site.websiteTitle || "",
        useBreadCrumbURL: site.useBreadCrumbURL || false,
        isRecipeSite: site.isRecipeSite || false,
        modifiedDT: site.modifiedDT || "",
        modifiedID: site.modifiedID || 0,
      } as Website)
  );
}

/**
 * Get website by ID
 */
export function getWebsiteById(id: number): Website | undefined {
  const websites = getWebsites();
  return websites.find((website) => website.id === id);
}

/**
 * Get menu items for a website
 */
export function getMenuItemsByWebsite(websiteId: number): MenuItem[] {
  // Safe type conversion for menu items
  const menuData = menuItemsData as any;
  const items = menuData[websiteId.toString()] || menuData[websiteId] || [];

  return items.map(
    (item: any) =>
      ({
        id: item.id || 0,
        domainID: item.domain_id || item.domainID || 0,
        domainName: item.domain_name || item.domainName || "",
        title: item.title || item.page_title || "",
        icon: item.icon || "",
        pageContent: item.page_content || item.pageContent || "",
        action: item.action || "",
        controller: item.controller || "",
        argument: item.argument || "",
        url: item.url || item.virtual_path || "",
        description: item.description || "",
        displayInNavigation:
          item.display_navigation || item.displayInNavigation || false,
        displayOrder: item.order || item.displayOrder || 0,
        parentId: item.parent_id || item.parentId || 0,
        parentTitle: item.parent_title || item.parentTitle || "",
        lastModified: item.last_modified || item.lastModified || "",
      } as MenuItem)
  );
}

/**
 * Get complete API data with metadata
 */
export function getApiData(): ApiData {
  // Safe conversion of API data
  const data = apiData as any;
  return {
    recipes: getRecipes(),
    categories: getCategories(),
    websites: getWebsites(),
    menuItems: Object.keys(data.menuItems || {}).reduce((acc, key) => {
      const numKey = parseInt(key);
      acc[numKey] = getMenuItemsByWebsite(numKey);
      return acc;
    }, {} as Record<number, MenuItem[]>),
    metadata: data.metadata || {
      fetchedAt: new Date().toISOString(),
      totalRecipes: getRecipes().length,
      totalCategories: getCategories().length,
      totalWebsites: getWebsites().length,
    },
  };
}

/**
 * Search recipes by name, description, or ingredients
 */
export function searchRecipes(query: string): Recipe[] {
  if (!query.trim()) return [];

  const recipes = getRecipes();
  const searchTerm = query.toLowerCase();

  return recipes.filter(
    (recipe) =>
      recipe.name?.toLowerCase().includes(searchTerm) ||
      recipe.description?.toLowerCase().includes(searchTerm) ||
      recipe.ingredients?.toLowerCase().includes(searchTerm)
  );
}

/**
 * Get featured recipes (highest rated or most recent)
 */
export function getFeaturedRecipes(limit: number = 6): Recipe[] {
  const recipes = getRecipes();

  // Sort by average rating (descending) and then by creation date (most recent)
  return recipes
    .sort((a, b) => {
      const ratingA = a.averageRating || 0;
      const ratingB = b.averageRating || 0;

      if (ratingA !== ratingB) {
        return ratingB - ratingA;
      }

      // Secondary sort by creation date
      const dateA = new Date(a.createdDT || 0);
      const dateB = new Date(b.createdDT || 0);
      return dateB.getTime() - dateA.getTime();
    })
    .slice(0, limit);
}

/**
 * Get recipe statistics
 */
export function getRecipeStats() {
  const recipes = getRecipes();
  const categories = getCategories();

  const stats = {
    totalRecipes: recipes.length,
    totalCategories: categories.length,
    averageRating: 0,
    recipesByCategory: {} as Record<string, number>,
    recentRecipes: 0,
  };

  // Calculate average rating
  const ratedRecipes = recipes.filter((r) => r.averageRating);
  if (ratedRecipes.length > 0) {
    stats.averageRating =
      ratedRecipes.reduce((sum, r) => sum + (r.averageRating || 0), 0) /
      ratedRecipes.length;
  }

  // Count recipes by category
  categories.forEach((category) => {
    const count = recipes.filter(
      (r) => r.recipeCategoryID === category.id
    ).length;
    stats.recipesByCategory[category.name] = count;
  });

  // Count recent recipes (last 30 days)
  const thirtyDaysAgo = new Date();
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
  stats.recentRecipes = recipes.filter((r) => {
    const createdDate = new Date(r.createdDT || 0);
    return createdDate > thirtyDaysAgo;
  }).length;

  return stats;
}

/**
 * Get data freshness information
 */
export function getDataMetadata() {
  try {
    const data = getApiData();
    return data.metadata;
  } catch {
    return {
      fetchedAt: "Unknown",
      totalRecipes: 0,
      totalCategories: 0,
      totalWebsites: 0,
    };
  }
}
